// contracts/DungeonsAndDragonsCharacter.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import "@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol";
import "@chainlink/contracts/src/v0.8/VRFConsumerBase.sol";
import "@openzeppelin/contracts/utils/Counters.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "hardhat/console.sol";

/// @title BigBangTheory Game
/// @author Ishita Rastogi Pranshu Rastogi
/// @notice Using our BBT Token user can play IQ guessing game, generated by chainlink vrf
/// if you win you will get twice the deposited amount you spent for playing.ðŸ˜ðŸ™€ðŸ™ˆ
contract BigBangTheory is ERC721URIStorage, VRFConsumerBase {
    using Counters for Counters.Counter;
    Counters.Counter private _tokenIds;
    bytes32 internal keyHash;
    uint256 internal fee;
    uint256 public randomResult;
    address public VRFCoordinator;
    address public LinkToken;

    IERC20 public token;
    uint256 public bbtTokensPerEth = 100;
    uint256 private characterIQ;

    event tokenPurchase(address buyer, uint256 amountOfTokens);

    struct BBTCharacterAttributes {
        string name;
        string occupation;
        string lover;
        string university;
        uint256 senseOfHumour;
        uint256 extrovert;
        uint256 socialSkills;
        uint256 sensitive;
        uint256 iq;
    }
    string[4] characterName;
    string[4] characterLovers;
    string[4] characterUniversities;
    string[4] characterOccupation;

    BBTCharacterAttributes[] public characters;

    mapping(bytes32 => address) senderAddress;
    mapping(bytes32 => BBTCharacterAttributes) characterDetails;

    //Rinkeby Network
    // LINK	0x01BE23585060835E02B77ef475b0Cc51aA1e0709
    // VRF Coordinator	0xb3dCcb4Cf7a26f6cf6B120Cf5A73875B7BBc655B
    // Key Hash	0x2ed0feb3e7fd2022120aa84fab1945545a9f2ffc9076fd6156fa96eaff4c1311
    // Fee	0.1 LINK
    constructor(
        address _VRFCoordinator,
        address _LinkToken,
        bytes32 _keyhash,
        IERC20 _token
    )
        public
        VRFConsumerBase(_VRFCoordinator, _LinkToken)
        ERC721("BigBangTheory", "BBT")
    {
        characterName = ["Raj", "Howard", "Leanord", "Sheldon"];
        characterLovers = ["Cinnamon", "Bernadette", "Penny", "Amy"];
        characterUniversities = [
            "Cambridge University",
            "MIT",
            "Princeton University",
            "Caltech"
        ];
        characterOccupation = [
            "AstroPhysics",
            "Aerospace engineer",
            "Experimental Physicist",
            "Theoritical Physicist"
        ];
        VRFCoordinator = _VRFCoordinator;
        LinkToken = _LinkToken;
        keyHash = _keyhash;
        fee = 0.1 * 10**18;
        token = _token;
    }

    /// @notice request to the VRF coordinator
    /// @param _iq set any random iq value
    /// @return The ID unique to a single request.
    function requestRandomAttributes(uint256 _iq) public returns (bytes32) {
        require(_iq >= 100 && _iq <= 200, "IQ range should lies in 100-200");
        require(LINK.balanceOf(address(this)) >= fee, "Not enough LINK ");
        characterIQ = _iq;

        uint256 tokensToPlay = 1 ether / bbtTokensPerEth;

        uint256 allowance = token.allowance(msg.sender, address(this));
        require(allowance >= tokensToPlay, "Check the token allowance");
        token.transferFrom(msg.sender, address(this), tokensToPlay);
        bytes32 requestId = requestRandomness(keyHash, fee);

        senderAddress[requestId] = msg.sender;
        return requestId;
    }

    /// @notice Sets _tokenURI as the tokenURI of tokenId.
    /// @param tokenId unique id of each NFT
    /// @param _tokenURI string foe setting meta data for NFT
    function setTokenURI(uint256 tokenId, string memory _tokenURI) public {
        require(
            _isApprovedOrOwner(_msgSender(), tokenId),
            "ERC721: transfer caller is not owner nor approved"
        );
        _setTokenURI(tokenId, _tokenURI);
    }

        function getTokenURI(uint256 tokenId) public view returns (string memory) {
        return tokenURI(tokenId);
    }


    /// @notice Called by VRFCoordinator when it receives a valid VRF proof
    /// @param requestId set any random iq value
    /// @param randomNumber  Random number generated by Chainlink VRF.
    function fulfillRandomness(bytes32 requestId, uint256 randomNumber)
        internal
        override
    {
        uint256 newItemId = _tokenIds.current();
        for (uint256 i = 0; i <= characters.length; i++) {
            characterDetails[requestId].name = characterName[i];
            characterDetails[requestId].occupation = characterOccupation[i];
            characterDetails[requestId].lover = characterLovers[i];
            characterDetails[requestId].university = characterUniversities[i];
        }
        uint256 senseOfHumour = uint256(
            keccak256(abi.encode(randomNumber, 1))
        ) % 100;
        uint256 extrovert = uint256(keccak256(abi.encode(randomNumber, 2))) %
            100;
        uint256 SocialSkills = uint256(keccak256(abi.encode(randomNumber, 3))) %
            100;
        uint256 sensitive = uint256(keccak256(abi.encode(randomNumber, 4))) %
            100;
        uint256 iq = uint256(keccak256(abi.encode(randomNumber, 5))) % 100;
        iq = iq + 100;
        BBTCharacterAttributes memory character = BBTCharacterAttributes(
            characterDetails[requestId].name,
            characterDetails[requestId].occupation,
            characterDetails[requestId].lover,
            characterDetails[requestId].university,
            senseOfHumour,
            extrovert,
            SocialSkills,
            sensitive,
            iq
        );
        characterDetails[requestId] = character;
        characters.push(character);

        _safeMint(senderAddress[requestId], newItemId);
        _tokenIds.increment();
        guessTheIQ(characterIQ, requestId);
    }

    /// @notice function to buy  BBT token
    /// @dev must have some ether to buy tokens
    function buy() public payable {
        require(msg.value > 0, "value should be greater than zero");
        uint256 tokenToPurchase = msg.value * bbtTokensPerEth;
        //This contract should have enough amount of token to execute the transaction
        uint256 balance = token.balanceOf(address(this));
        require(
            tokenToPurchase <= balance,
            "Not enough tokens in the contract"
        );
        // Transfer token to the msg.sender
        bool sent = token.transfer(msg.sender, tokenToPurchase);
        require(sent, "Token transfer failed");
        emit tokenPurchase(msg.sender, tokenToPurchase);
    }

    function getNumberOfCharacters() public view returns (uint256) {
        return characters.length;
    }

    /// @notice If your guessed IQ is 15 more or less that the actual
    //verifiable randomly generated IQ you receive twice of the deposited tokens
    function guessTheIQ(uint256 _iq, bytes32 requestId) internal {
        uint256 tokensToPlay = 1 ether / bbtTokensPerEth;

        if (
            (_iq <= characterDetails[requestId].iq + 15 &&
                _iq >= characterDetails[requestId].iq) ||
            (_iq >= characterDetails[requestId].iq - 15 &&
                _iq <= characterDetails[requestId].iq)
        ) {
            bool sents = token.transfer(
                senderAddress[requestId],
                tokensToPlay * 2
            );
            require(sents, "Token transfer failed");
        }
    }
}
